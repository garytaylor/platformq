As well as recording what I am doing in the git history, below is a bit more detail on how this was developed from the beginning :-

Please note that I have approached this as if it were a bigger piece of work in order to demonstrate various methods.
If this really was a tiny system with a limited budget, I would probably take a different approach such as not using
JSON as a data transfer, but let rails do the HTML creation using erb templates and just add any unobtrusive javascript
if the page needed it.  However, I felt maybe this is not what you are looking for.

1. Install rails and create rails project.  This was done using the standard rails script with a postgresql database and jquery javascript.
  Whilst I wasnt 100% sure if I wanted jquery - the chances are I will, so I am leaving it in.

2. I never use turbolinks - as the UI tends to be interfaced using JSON rather than HTML snippets which it was designed for

3. Added rspec for the test runner, capybara along with site-prism to implement 'Page Objects' which allow the test code to
    easily 'see' the output that the user sees.  This uses selenium and a real browser.  This may or may not be required
    on a small project like this as it is very easy to test manually, I guess I am just demonstrating a professional approach
    which could easily be scaled down or removed if it was felt to be 'over the top'.

4. Initialized rspec in the project using the standard 'rspec --init' script

5. Added integration test for the main blog page.
    Whilst I probably wont get time to do this properly in a short space of time, it is in place just to show a typical workflow
    Working at this level and not worrying too much about the detail is where I tend to start, so I refer to page objects that
    dont exist yet and helpers that I havent defined yet, all with the aim of keeping the tests so they dont get too complex
    and they remain as DRY as possible.

6. Now that I have an idea of what I want to develop and I have my integration tests in place, probably just for the feature
    that I am developing rather than trying to put them in for the whole system all at once, I can now start to see what
    information needs to flow to/from the user, so I start to document this in the form of a 'json schema'.  I have included
    a gem called 'json-schema' that is capable of validating against this, which again, keeps the request specs easier to
    read and DRY as I simply need to say 'expect(something).to be_valid_json_for(this_schema) or something similar.

    Whilst the integration tests cover end to end - i.e from the user interface all the way through to the I/O (database etc..)
    it is important to write specs at a lower level as well to allow me to focus on a particular area during development
    (for example, I may be in ruby mode and not want to keep switching to javascript, so lets get the API written then jump
    to the UI).  It also allows other developers to work on the UI in isolation whilst I develop the API.

    The other benefit is that the json schemas become a 'contract' between the UI and the server.  Every developer will
    know that if a change is required to one of these 'contracts', then all parties using the contract need to be made
    aware of the change.  Not particularly important in a simple blog application but important if it grew into something
    bigger.

7. Next, I decide on how the database maps to the json contracts.  In this case, there will be quite a simple mapping
    the json data will more than likely be a subset of the data from the database.  So, I go ahead and define the models.
    I will use the rails generators for only the models as it does a good job, but I also installed devise as it has
    a generator for the user model.
    The user model was then generated by devise and I simply added a non null name field to the migration as this will
    show the author of a blog or a comment

8. Now that we have the user model, I then add the articles and comments models with their associated migrations.  Again,
    I have no problem using generators for this as they do a good job.  The articles will have a 'has many' association
    with the comments as indicated by the json schema, so I will bear this in mind when creating the models.

9. Now I can get data to/from the database, to be able to programatically create entities from test code, I prefer to use
    factory girl, so I will add this to the gemfile.  I have also added the faker gem to help generate some dummy data.
    A basic factory for the user and article has now been generated and used in the new articles_spec which is a request spec
    for testing the API

10. Added route for articles index action.  I have done this using 'resources' even though there is only one route.  This
     is simply because I am expecting to add more.  I have restricted resources to only generate a route for index
     the reason for this is I prefer to be in control of the routes generated rather than just let it generate all 7 typical REST actions.
     This way, I dont end up with wasted routes that never get used.

11. Added articles controller as the request spec saw that as the first thing that failed.  Just added index action for now
    just so I remain focussed on one failure at a time unless I can immediately see a pattern where I could fix many test
    failures easily in 1 place.

12. The request spec was then made to work and detect the fact that we have absolutely nothing coming out of the controller
     as the view file (articles/index.json.jbuilder) was previously coded to output just the basic structure.
     Also, set strict mode in the schema validation to ensure that what is output is exactly how we want it, no extra fields
     like 'created_on', or foreign keys that the user interface is not interested in etc...
     Made the nescessary changes to make the request spec pass.

13. Added an entry point for the app in the form of a welcome controller's index action.
     Added an ExtJS app for displaying the contents of the working REST end point.  This is not completed at this point,
     but added just to get the basics working and ensure that everything is wired together properly.

14. Added markdown support for the body of the article using the showdown js library.  Performing the converter in the
    browser was preferred over server side conversion - mainly so that when we come to providing a UI for entering markdown
    into the system, we can do preview as you type rather than having to keep asking the server for a preview.  Also,
    if we keep the server focussed on just delivering the JSON in a standard form and let the UI deal with presenting that
    data to the user, this will keep the server performing well as it has less work to do.

15. Added ability to show a blog entry by double clicking in view.  At present, this uses the data that was already loaded when the
    list was generated.  This is a little inefficient as this means that the list has to load everything - including the body, all of
    the comments etc... just in case the user double clicks on it.  If this were to be done slightly better, I would have made the
    viewer fetch the data straight from the server and perhaps reduce the data sent in the list to just that data required by the list.
    In an agile environment, this would be classed as OK though as we would then enhance at a later stage when performance was a concern
    or we needed something like pagination.

16. In order to implement subscriptions - I have added a subscription model along with an article mailer.  This uses active job to send
        the emails in the background.  I have configured this with delayed_job as there are no external dependencies.  Personally I prefer
        sidekiq for performance reasons, but it means for the code to run, redis needed to be installed.
        So far, the subscriptions work when tested with an integration test with mocked data.  The next step is to implement the UI
        for it.

17. Added spec and implementation for REST endpoint for subscriptions (create only - we dont want others grabbing a list of who is subscribed)




