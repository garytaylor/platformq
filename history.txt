As well as recording what I am doing in the git history, below is a bit more detail on how this was developed from the beginning :-

Please note that I have approached this as if it were a bigger piece of work in order to demonstrate various methods.
If this really was a tiny system with a limited budget, I would probably take a different approach such as not using
JSON as a data transfer, but let rails do the HTML creation using erb templates and just add any unobtrusive javascript
if the page needed it.  However, I felt maybe this is not what you are looking for.

1. Install rails and create rails project.  This was done using the standard rails script with a postgresql database and jquery javascript.
  Whilst I wasnt 100% sure if I wanted jquery - the chances are I will, so I am leaving it in.

2. I never use turbolinks - as the UI tends to be interfaced using JSON rather than HTML snippets which it was designed for

3. Added rspec for the test runner, capybara along with site-prism to implement 'Page Objects' which allow the test code to
    easily 'see' the output that the user sees.  This uses selenium and a real browser.  This may or may not be required
    on a small project like this as it is very easy to test manually, I guess I am just demonstrating a professional approach
    which could easily be scaled down or removed if it was felt to be 'over the top'.

4. Initialized rspec in the project using the standard 'rspec --init' script

5. Added integration test for the main blog page.
    Whilst I probably wont get time to do this properly in a short space of time, it is in place just to show a typical workflow
    Working at this level and not worrying too much about the detail is where I tend to start, so I refer to page objects that
    dont exist yet and helpers that I havent defined yet, all with the aim of keeping the tests so they dont get too complex
    and they remain as DRY as possible.

6. Now that I have an idea of what I want to develop and I have my integration tests in place, probably just for the feature
    that I am developing rather than trying to put them in for the whole system all at once, I can now start to see what
    information needs to flow to/from the user, so I start to document this in the form of a 'json schema'.  I have included
    a gem called 'json-schema' that is capable of validating against this, which again, keeps the request specs easier to
    read and DRY as I simply need to say 'expect(something).to be_valid_json_for(this_schema) or something similar.

    Whilst the integration tests cover end to end - i.e from the user interface all the way through to the I/O (database etc..)
    it is important to write specs at a lower level as well to allow me to focus on a particular area during development
    (for example, I may be in ruby mode and not want to keep switching to javascript, so lets get the API written then jump
    to the UI).  It also allows other developers to work on the UI in isolation whilst I develop the API.

    The other benefit is that the json schemas become a 'contract' between the UI and the server.  Every developer will
    know that if a change is required to one of these 'contracts', then all parties using the contract need to be made
    aware of the change.  Not particularly important in a simple blog application but important if it grew into something
    bigger.

7. Next, I decide on how the database maps to the json contracts.  In this case, there will be quite a simple mapping
    the json data will more than likely be a subset of the data from the database.  So, I go ahead and define the models.
    I will use the rails generators for only the models as it does a good job, but I also installed devise as it has
    a generator for the user model.
    The user model was then generated by devise and I simply added a non null name field to the migration as this will
    show the author of a blog or a comment

8. Now that we have the user model, I then add the articles and comments models with their associated migrations.  Again,
    I have no problem using generators for this as they do a good job.  The articles will have a 'has many' association
    with the comments as indicated by the json schema, so I will bear this in mind when creating the models.

9. Now I can get data to/from the database, to be able to programatically create entities from test code, I prefer to use
    factory girl, so I will add this to the gemfile.  I have also added the faker gem to help generate some dummy data.
    A basic factory for the user and article has now been generated and used in the new articles_spec which is a request spec
    for testing the API







